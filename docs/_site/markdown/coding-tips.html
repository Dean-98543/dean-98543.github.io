<!DOCTYPE html>
<html lang="zh">

<head>
  <title>LeetCode</title>
  <link rel="stylesheet" href="../assets/css/typora-github.css">
</head>

<body>
  <div class="markdown-body">
    <h1 id="bitwise-operation">Bitwise Operation</h1>

<ol>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 &lt;&lt; n
2 ** n
</code></pre></div>    </div>

    <blockquote>
      <p>在python中，上述两种方式是等价的，都用来计算2的n次方。</p>
    </blockquote>
  </li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mask = (1 &lt;&lt; n) - 1
</code></pre></div>    </div>

    <blockquote>
      <p>mask = (1 « n) - 1 主要用于生成一个位掩码，该掩码在低位具有 n 个连续的 1，而高位则为 0</p>
    </blockquote>
  </li>
  <li></li>
</ol>

<h1 id="数论">数论</h1>

<h2 id="异或">异或</h2>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Python</code>和<code class="language-plaintext highlighter-rouge">C++</code>中的异或符号均为<code class="language-plaintext highlighter-rouge">^</code></li>
  <li>相同整数（不论正数还是负数）的异或结果为<code class="language-plaintext highlighter-rouge">0</code>：<code class="language-plaintext highlighter-rouge">x^x=0</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">0</code>与任何正整数或者负整数异或的结果都等于那个数：<code class="language-plaintext highlighter-rouge">0^3 = 3</code></li>
      <li><code class="language-plaintext highlighter-rouge">偶数</code>与<code class="language-plaintext highlighter-rouge">偶数+1</code>的异或结果为<code class="language-plaintext highlighter-rouge">1</code>（相对应的，<code class="language-plaintext highlighter-rouge">奇数</code>与<code class="language-plaintext highlighter-rouge">奇数-1</code>的异或结果为<code class="language-plaintext highlighter-rouge">1</code>），但是偶数与偶数-1的异或结果不确定（相对应的，奇数与奇数+1的异或结果也不确定）：<code class="language-plaintext highlighter-rouge">odd^(odd-1) = 1</code>，<code class="language-plaintext highlighter-rouge">even^(even+1) = 1</code></li>
      <li>异或满足交换律：<code class="language-plaintext highlighter-rouge">a^b^c = a^c^b = b^a^c = b^c^a = c^a^b = c^b^a</code></li>
    </ol>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Python
</span><span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="o">^-</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="mi">312</span><span class="o">^-</span><span class="mi">311</span><span class="p">)</span>    <span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="mi">45</span><span class="o">^</span><span class="mi">45</span><span class="p">)</span>        <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">1</span><span class="p">)</span>          <span class="c1"># 3
</span><span class="nf">print</span><span class="p">(</span><span class="mi">32</span><span class="o">^</span><span class="mi">31</span><span class="p">)</span>        <span class="c1"># 63
</span><span class="nf">print</span><span class="p">(</span><span class="mi">32</span><span class="o">^</span><span class="mi">33</span><span class="p">)</span>        <span class="c1"># 1
</span></code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span><span class="o">^-</span><span class="mi">1000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">312</span><span class="o">^-</span><span class="mi">311</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">45</span><span class="o">^</span><span class="mi">45</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">32</span><span class="o">^</span><span class="mi">31</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">32</span><span class="o">^</span><span class="mi">33</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1000^-1000:"</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>      <span class="c1">// 0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-312^-311:"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>        <span class="c1">// 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"45^45:"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>            <span class="c1">// 0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2^1:"</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>              <span class="c1">// 3</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"32^31:"</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>            <span class="c1">// 63</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"32^33:"</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>            <span class="c1">// 1</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="与">与</h2>

<ol>
  <li>
    <p>判断某一个正整数，其二进制表示的倒数第i位是否为1：(num»i&amp;1)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 若判断13的二进制表示（1101）的倒数第2位是什么（即是0还是1）：
</span><span class="nf">print</span><span class="p">(</span><span class="mi">13</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>		<span class="c1"># 1
# 判断71的二进制表示（1000111）的倒数第i位是什么：
</span><span class="nf">print</span><span class="p">(</span><span class="mi">71</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>		<span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="mi">71</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>		<span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="mi">71</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>		<span class="c1"># 1
</span></code></pre></div>    </div>
  </li>
</ol>

<h2 id="右移--左移">右移 &amp; 左移</h2>

<p>一个int类型的num:</p>

<ul>
  <li>num » i &amp;1 相当于提取该num的二进制形式中的第i位的数字</li>
  <li></li>
</ul>

<h2 id="逻辑运算符">逻辑运算符</h2>

<ol>
  <li>
    <p>Python中，and和or并不返回bool值，而是返回他们实际进行比较的值之一</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># and
</span><span class="nf">print</span><span class="p">(</span><span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 2
</span><span class="nf">print</span><span class="p">(</span><span class="mi">1</span> <span class="ow">and</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 4
</span><span class="nf">print</span><span class="p">(</span><span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># 8
</span><span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="c1"># -5
# or
</span><span class="nf">print</span><span class="p">(</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="mi">0</span> <span class="ow">or</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># 2
</span><span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># -1
</span><span class="nf">print</span><span class="p">(</span><span class="mi">0</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="mi">0</span> <span class="ow">or</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># -3
</span></code></pre></div>    </div>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>但是C++中，&amp;&amp; 和</td>
          <td> </td>
          <td>返回bool值，虽然也进行逻辑运算符两边式子的计算，但是整体的逻辑运算符返回bool值</td>
        </tr>
      </tbody>
    </table>

    <pre><code class="language-C++">int a1 = 6;
bool b = 2 &amp;&amp; (a1++);
cout &lt;&lt; boolalpha &lt;&lt; a1 &lt;&lt; endl;    // 7
cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;     // true
   
int a2 = 6;
bool c = 0 &amp;&amp; (a2++);
cout &lt;&lt; boolalpha &lt;&lt; a2 &lt;&lt; endl;    // 6
cout &lt;&lt; boolalpha &lt;&lt; c &lt;&lt; endl;     // false
</code></pre>
  </li>
  <li></li>
</ol>

<h2 id="最大公约数gcd">最大公约数（GCD）</h2>

<p>最大公约数（Greatest Common Divisor GCD or Highest Common Factor HCF）</p>

<p>欧几里得算法又叫辗转相除法，是指用于计算两个正整数a和b的最大公约数：<strong>以除数和余数反复做除法运算，当余数为0时，取当前算式除数为最大公约数</strong></p>

<p>其计算原理依赖于下面的定理：<strong>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    用来计算两个正整数a和b的最大公约数
    欧几里得算法（辗转相除法）：
    以除数和余数反复做除法运算，当余数为0时，取当前算式除数为最大公约数
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">b</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">self</span><span class="p">.</span><span class="nf">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="cm">/*
    用来计算两个正整数a和b的最大公约数
    欧几里得算法（辗转相除法）：
    以除数和余数反复做除法运算，当余数为0时，取当前算式除数为最大公约数
    */</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span> <span class="n">a</span><span class="o">:</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="最小公倍数lcm">最小公倍数（LCM）</h2>

<p>最小公倍数（Least Common Multiple）</p>

<h2 id="gcd和lcm的关系">GCD和LCM的关系</h2>

<p>两个数的乘积等于这两个数的最大公约数和最小公倍数的乘积。假设两个数分别为a和b，他们的最大公约数是gcd，最小公倍数是lcm，则存在这样的关系式：\(a*b=gcd*lcm\)</p>

<h1 id="数据结构与算法">数据结构与算法</h1>

<h2 id="单调栈">单调栈</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="n">Python3</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">nextGreaterElement</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># 解法一：单调栈
</span>        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">st</span> <span class="ow">and</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">st</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">st</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nextGreaterElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dic</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="n">nums2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()){</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">num</span><span class="o">:</span> <span class="n">nums1</span><span class="p">){</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="二分查找">二分查找</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchInsert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="k">return</span> <span class="n">N</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">:</span> 
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mid</span>
        <span class="k">return</span> <span class="n">l</span>    <span class="c1"># 若没查找到target，即返回target的插入位置
</span></code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">searchInsert</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">.</span><span class="n">back</span><span class="p">())</span>  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">;</span>   <span class="c1">// 若没查找到target，即返回target的插入位置</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="并查集union-find-disjoint-sets">并查集（union-find disjoint sets）</h2>

<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的树根，就能确定它在哪个集合里。</p>

<p>并查集的主要操作是合并和查询，它是把初始不相交的集合经过多次合并操作后合并为一个大集合，然后通过查询判断两个元素是否在一个大的集合中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        初始化并查集：保证每一个元素都不相交，以等待合并union操作
        </span><span class="sh">'''</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>   <span class="c1"># 用作union条件，需要根据题意调整
</span>        <span class="n">self</span><span class="p">.</span><span class="n">setCount</span> <span class="o">=</span> <span class="n">n</span>   <span class="c1"># 并查集里的集合个数，初始默认相互独立
</span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>  <span class="c1"># 查
</span>        <span class="sh">'''</span><span class="s">
        查找x的根节点
        </span><span class="sh">'''</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>     <span class="c1"># 如果x本身就是根节点，即自己是自己的祖先
</span>            <span class="k">return</span> <span class="n">x</span>
        <span class="c1"># 否则继续找x的父亲的祖先
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>    <span class="c1"># 递归找到x的祖先
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># 并
</span>        <span class="sh">'''</span><span class="s">
        连通x和y，让y指向x（x&lt;-y）
        </span><span class="sh">'''</span>
        <span class="n">x_root</span><span class="p">,</span> <span class="n">y_root</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_root</span> <span class="o">==</span> <span class="n">y_root</span><span class="p">:</span>    <span class="c1"># 如果x和y的祖先相同，即在一个集合里
</span>            <span class="k">return</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
            <span class="n">x_root</span><span class="p">,</span> <span class="n">y_root</span> <span class="o">=</span> <span class="n">y_root</span><span class="p">,</span> <span class="n">x_root</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">y_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_root</span>    <span class="c1"># 将y的祖先指向x的祖先，即现在y的祖先是x的祖先，实现了并
</span>        <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">x_root</span><span class="p">]</span><span class="o">+=</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">y_root</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">setCount</span><span class="o">-=</span><span class="mi">1</span>    <span class="c1"># 每连通两个节点，集合数减一
</span>    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        判断x和y连通与否
        </span><span class="sh">'''</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="前缀树">前缀树</h2>

<p>前缀树（Trie数）是一种用于快速检索的多叉数结构，利用字符串的公共前缀来降低复杂度，核心思想是空间换时间，经常用搜索引擎用于文本词频统计</p>

<pre><code class="language-Python">class Trie:
    def __init__(self):
        self.children = dict()
        self.isEnd = False

    def insert(self, prefix: str) -&gt; None:
        cur = self
        for c in prefix:
            if c not in cur.children:
                cur.children[c] = Trie()
            cur = cur.children[c]
        cur.isEnd = True


    def find_prefix(self, word:str) -&gt; str:
        cur = self
        for i, c in enumerate(word):
            if c not in cur.children:
                return word
            cur = cur.children[c]
            if cur.isEnd:
                return word[:i + 1]
        return word
</code></pre>

<h2 id="前缀和">前缀和</h2>

<p>前缀和的不同写法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 写法一：新建O(n)空间的写法
</span><span class="k">def</span> <span class="nf">preSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
		<span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
  	<span class="n">res</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span>
  	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    		<span class="n">pre</span><span class="o">+=</span><span class="n">num</span>
    		<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 写法二：在原数组上修改
</span><span class="k">def</span> <span class="nf">preSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nums</span>
</code></pre></div></div>

<h2 id="置换环">置换环</h2>

<p>环状图：一个有向图如果有n个点，n条边，并且每个点的入度和出度都为1，这样的图被称为环状图。</p>

<p>例如在原数组arr=[2, 0, 1, 4, 3]中，[2, 0, 1]和[4, 3]分别是两个置换环。环与环之间数字不发生交换，只会在环内发生交换。那怎么从原数组中找到一个个环呢？答案是：从第一个数字开始，把这个数字当做下标去访问数组（对于原数组中元素不是某个下标的情况，需要做元素到下标的映射），不断循环知道回到这个数本身。</p>

<p>对于每个环，环内的交换次数为环的大小减一。所以不难推算出：原数组的最小交换次数=原数组大小-环的个数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">swap_cnt</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">s_arr</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">n2i</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">n2i</span><span class="p">[</span><span class="n">s_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>   <span class="c1"># 每个数字对应的【排序后的位置索引】
</span>
    <span class="c1"># 看有多少个置换环，环与环之间不会发生交换，只有在环内的两个数字才会发生交换
</span>    <span class="n">loops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>   <span class="c1"># 一步步走完当前的环
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">n2i</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>     <span class="c1"># 看下当前的数字应该在【排序后的哪个位置】:即把这个数字当做下标去访问数组
</span>        <span class="n">loops</span> <span class="o">+=</span> <span class="mi">1</span>    <span class="c1"># 环的个数
</span>    <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="n">loops</span>    <span class="c1"># 环内的交换次数为【环的大小-1】，则数组的总交换次数=每个换的环内交换个数之和
</span></code></pre></div></div>

<p>参考：</p>

<ol>
  <li><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solution/by-endlesscheng-97i9/">BFS + 置换环 + 离散化</a></li>
  <li><a href="https://blog.csdn.net/weixin_42638946/article/details/120437662?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120437662-blog-46981171.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120437662-blog-46981171.pc_relevant_aa2&amp;utm_relevant_index=1">【算法专题】环状图（置换群）</a></li>
</ol>

  </div>
</body>

</html>